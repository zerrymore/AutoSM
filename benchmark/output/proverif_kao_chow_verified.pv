free att:channel.
free s1:bitstring.
free s2:bitstring.
free s3:bitstring.
free s4:bitstring.
free s5:bitstring.
free sA:bitstring.
free sB:bitstring.
fun fst(bitstring):bitstring.
fun id(bitstring):bitstring.
fun pair(bitstring,bitstring):bitstring.
fun sdec(bitstring,bitstring):bitstring.
fun senc(bitstring,bitstring):bitstring.
fun snd(bitstring):bitstring.
event eCommit_A(bitstring,bitstring,bitstring).
event eCommit_B(bitstring,bitstring,bitstring).
event eIN_A_1(bitstring,bitstring).
event eIN_B_Na(bitstring,bitstring).
event eOUT_B_1(bitstring).
event eOUT_S_1(bitstring).
event eOut_A_Na(bitstring).
event eRunning_A(bitstring,bitstring,bitstring).
event eRunning_B(bitstring,bitstring,bitstring).
event eSecret(bitstring,bitstring,bitstring).
equation forall x_1:bitstring, x_2:bitstring;   fst((x_1, x_2)) = x_1.
equation forall x_1:bitstring, x_2:bitstring;   sdec(senc(x_1, x_2), x_2) = x_1.
equation forall x_1:bitstring, x_2:bitstring;   snd((x_1, x_2)) = x_2.
(*sources*)
(*(∀ x m #i.
    (IN_A_1( m, x ) @ #i) ⇒
    ((∃ #j. (!KU( x ) @ #j) ∧ (#j < #i)) ∨
     (∃ #j. (OUT_B_1( m ) @ #j) ∧ (#j < #i)))) ∧
  (∀ x m #i.
    (IN_B_Na( m, x ) @ #i) ⇒
    ((∃ #j. (!KU( x ) @ #j) ∧ (#j < #i)) ∨
     (∃ #j. (OUT_S_1( m ) @ #j) ∧ (#j < #i))))*)
(*secrecy*)
query A:bitstring, B:bitstring, k:bitstring, i:time, j:time;
 (event(eSecret( A, B, k ))@i) ==> (not(attacker( k )@j))
.
(*injectiveagreement_B*)
query A:bitstring, A2:bitstring, B:bitstring, B2:bitstring, t:bitstring,
      i:time, i2:time, j:time;
 (event(eCommit_B( A, B, t ))@i) ==>
 (((event(eRunning_A( A, B, t ))@j) && (j < i)) &&
  (not((event(eCommit_B( A2, B2, t ))@i2) && (i2 <> i))))
.
(*agreement_B*)
query A:bitstring, B:bitstring, t:bitstring, i:time, j:time;
 (event(eCommit_B( A, B, t ))@i) ==>
 ((event(eRunning_A( A, B, t ))@j) && (j < i))
.
(*injectiveagreement_A*)
query A:bitstring, A2:bitstring, B:bitstring, B2:bitstring, t:bitstring,
      i:time, i2:time, j:time;
 (event(eCommit_A( A, B, t ))@i) ==>
 (((event(eRunning_B( A, B, t ))@j) && (j < i)) &&
  (not((event(eCommit_A( A2, B2, t ))@i2) && (i2 <> i))))
.
(*agreement_A*)
query A:bitstring, B:bitstring, t:bitstring, i:time, j:time;
 (event(eCommit_A( A, B, t ))@i) ==>
 ((event(eRunning_B( A, B, t ))@j) && (j < i))
.
let A(Kas_1:bitstring, idA_1:bitstring, idB_1:bitstring)=
    new Na_1:bitstring;
    event eOut_A_Na( Na_1 );
    out(att,(s1, (idA_1, (idB_1, Na_1))));
    in(att,cypher_1:bitstring);
    let (package1_1:bitstring, (message_1:bitstring, Nb_1:bitstring))=cypher_1 in
    let (=s2, (=idA_1, (=idB_1, (=Na_1, Kab_1:bitstring))))=sdec(package1_1,
                                                                 Kas_1) in
    let (=s4, =Na_1)=sdec(message_1, Kab_1) in
    event eIN_A_1( cypher_1, Nb_1 );
    event eSecret( idA_1, idB_1, Kab_1 );
    event eCommit_A( idA_1, idB_1, (sA, (sB, (Na_1, Kab_1))) );
    event eRunning_A( idA_1, idB_1, (sA, (sB, (Nb_1, Kab_1))) );
    out(att,senc((s5, Nb_1), Kab_1)).
let B(Kbs_1:bitstring, idA_1:bitstring, idB_1:bitstring)=
    in(att,cypher_1:bitstring);
    let (package1_1:bitstring, package2_1:bitstring)=cypher_1 in
    let (=s3, (=idA_1, (=idB_1, (Na_1:bitstring, Kab_1:bitstring))))=sdec(package2_1,
                                                                          Kbs_1) in
    event eSecret( idA_1, idB_1, Kab_1 );
    new Nb_1:bitstring;
    event eIN_B_Na( cypher_1, Na_1 );
    event eOUT_B_1( (package1_1, (senc((s4, Na_1), Kab_1), Nb_1)) );
    event eRunning_B( idA_1, idB_1, (sA, (sB, (Na_1, Kab_1))) );
    out(att,(package1_1, (senc((s4, Na_1), Kab_1), Nb_1)));
    in(att,cypher2_1:bitstring);
    let (=s5, =Nb_1)=sdec(cypher2_1, Kab_1) in
    event eCommit_B( idA_1, idB_1, (sA, (sB, (Nb_1, Kab_1))) ).
let S(Kas_1:bitstring, Kbs_1:bitstring, idA_1:bitstring,
      idB_1:bitstring)=
    in(att,(=s1, (=idA_1, (=idB_1, Na_1:bitstring))));
    new Kab_1:bitstring;
    let package1_1:bitstring=senc((s2, (idA_1, (idB_1, (Na_1, Kab_1)))),
                                  Kas_1) in
    let package2_1:bitstring=senc((s3, (idA_1, (idB_1, (Na_1, Kab_1)))),
                                  Kbs_1) in
    event eOUT_S_1( (package1_1, package2_1) );
    out(att,(package1_1, package2_1)).


process
    !
    (new Kas_1:bitstring;
     out(att,id(Kas_1));
     new Kbs_1:bitstring;
     out(att,id(Kbs_1));
     !
     (((A(Kas_1, id(Kas_1), id(Kbs_1)))
     | (!
        (((B(Kbs_1, id(Kas_1), id(Kbs_1)))
        | (!
           (S(Kas_1, Kbs_1, id(Kas_1), id(Kbs_1))))))))))

