free att:channel.
free s1:bitstring.
free s2:bitstring.
free s3:bitstring.
free s4:bitstring.
fun fst(bitstring):bitstring.
fun id(bitstring):bitstring.
fun pair(bitstring,bitstring):bitstring.
fun senc(bitstring,bitstring):bitstring.
fun snd(bitstring):bitstring.
event eAUTO_IN_TERM_1_0_1_0_1_1_1__S_1(bitstring,bitstring).
event eAUTO_IN_TERM_2_0_0_0_1_1_1_1__A_2(bitstring,bitstring).
event eAUTO_OUT_TERM_1_0_1_0_1_1_1__S_1(bitstring).
event eAUTO_OUT_TERM_2_0_0_0_1_1_1_1__A_2(bitstring).
event eCommitA(bitstring,bitstring,bitstring).
event eCommitB(bitstring,bitstring,bitstring).
event eIN_B(bitstring,bitstring).
event eOUT_A(bitstring).
event eRunningA(bitstring,bitstring,bitstring).
event eRunningB(bitstring,bitstring,bitstring).
event eSecret(bitstring,bitstring,bitstring).
event eServer(bitstring,bitstring,bitstring).
equation forall x_1:bitstring, x_2:bitstring;   fst((x_1, x_2)) = x_1.
equation forall x_1:bitstring, x_2:bitstring;   snd((x_1, x_2)) = x_2.
reduc forall k:bitstring, m:bitstring;   sdec(senc(m, k), k) = m.
(*AUTO_typing*)
(*(∀ x m #i.
    (AUTO_IN_TERM_1_0_1_0_1_1_1__S_1( m, x ) @ #i) ⇒
    ((∃ #j. (!KU( x ) @ #j) ∧ (#j < #i)) ∨
     (∃ #j. (AUTO_OUT_TERM_1_0_1_0_1_1_1__S_1( m ) @ #j) ∧ (#j < #i)))) ∧
  (∀ x m #i.
    (AUTO_IN_TERM_2_0_0_0_1_1_1_1__A_2( m, x ) @ #i) ⇒
    ((∃ #j. (!KU( x ) @ #j) ∧ (#j < #i)) ∨
     (∃ #j. (AUTO_OUT_TERM_2_0_0_0_1_1_1_1__A_2( m ) @ #j) ∧ (#j < #i))))*)
(*executability*)
query A:bitstring, B:bitstring, kab:bitstring, na:bitstring,
      nb:bitstring, i:time, j:time, k:time;
 ((((event(eCommitB( B, A, (kab, (na, nb)) ))@i) &&
    (event(eCommitA( A, B, (na, nb) ))@j)) &&
   (j < i)) &&
  (event(eServer( A, B, (kab, (na, nb)) ))@k)) &&
 (k < j)
.
(*secrecy*)
query A:bitstring, B:bitstring, k:bitstring, i:time, j:time;
 (event(eSecret( A, B, k ))@i) ==> (not(attacker( k )@j))
.
(*test*)
query A:bitstring, B:bitstring, t:bitstring, i:time, j:time;
 (event(eCommitB( B, A, t ))@i) ==> (event(eRunningA( A, B, t ))@j)
.
(*noninjectiveagreement_B*)
query A:bitstring, B:bitstring, t:bitstring, i:time, j:time;
 (event(eCommitB( B, A, t ))@i) ==>
 ((event(eRunningA( A, B, t ))@j) && (j < i))
.
(*noninjectiveagreement_A*)
query A:bitstring, B:bitstring, t:bitstring, i:time, j:time;
 (event(eCommitA( A, B, t ))@i) ==>
 ((event(eRunningB( B, A, t ))@j) && (j < i))
.
(*injectiveagreement_B*)
query A:bitstring, A2:bitstring, B:bitstring, B2:bitstring, t:bitstring,
      i:time, i2:time, j:time;
 (event(eCommitB( B, A, t ))@i) ==>
 (((event(eRunningA( A, B, t ))@j) && (j < i)) &&
  (not((event(eCommitB( B2, A2, t ))@i2) && (i2 <> i))))
.
(*injectiveagreement_A*)
query A:bitstring, A2:bitstring, B:bitstring, B2:bitstring, t:bitstring,
      i:time, i2:time, j:time;
 (event(eCommitA( A, B, t ))@i) ==>
 (((event(eRunningB( B, A, t ))@j) && (j < i)) &&
  (not((event(eCommitA( A2, B2, t ))@i2) && (i2 <> i))))
.
let Alice(Kas_1:bitstring, idA_1:bitstring, idB_1:bitstring)=
    new Na_1:bitstring;
    out(att,(idA_1, Na_1));
    in(att,(cypher1_1:bitstring, cypher2_1:bitstring));
    let mess1_1:bitstring=sdec(cypher1_1, Kas_1) in
    let (=s2, (=idB_1, (Kab_1:bitstring, (=Na_1, Nb_1:bitstring))))=mess1_1 in
    event eAUTO_IN_TERM_2_0_0_0_1_1_1_1__A_2( cypher1_1, Nb_1 );
    event eCommitA( idA_1, idB_1, (Na_1, Nb_1) );
    event eRunningA( idA_1, idB_1, (Kab_1, (Na_1, Nb_1)) );
    event eSecret( idA_1, idB_1, Kab_1 );
    event eOUT_A( senc((s4, Nb_1), Kab_1) );
    out(att,(cypher2_1, senc((s4, Nb_1), Kab_1))).
let Bob(Kas_1:bitstring, Kbs_1:bitstring, idA_1:bitstring,
        idB_1:bitstring)=
    in(att,(=idA_1, Na_1:bitstring));
    new Nb_1:bitstring;
    event eRunningB( idB_1, idA_1, (Na_1, Nb_1) );
    event eAUTO_OUT_TERM_1_0_1_0_1_1_1__S_1( senc((s1, (idA_1, (Na_1, Nb_1))),
                                                  Kbs_1)
          );
    out(att,senc((s1, (idA_1, (Na_1, Nb_1))), Kbs_1));
    in(att,(cypher3_1:bitstring, cypher4_1:bitstring));
    let mess2_1:bitstring=sdec(cypher3_1, Kbs_1) in
    let (=s3, (=idA_1, Kab_1:bitstring))=mess2_1 in
    let (=s4, =Nb_1)=sdec(cypher4_1, Kab_1) in
    event eIN_B( cypher4_1, Nb_1 );
    event eCommitB( idB_1, idA_1, (Kab_1, (Na_1, Nb_1)) );
    event eSecret( idB_1, idA_1, Kab_1 ).
let Server(Kas_1:bitstring, Kbs_1:bitstring, idA_1:bitstring,
           idB_1:bitstring)=
    in(att,cypher5_1:bitstring);
    let mess3_1:bitstring=sdec(cypher5_1, Kbs_1) in
    let (=s1, (=idA_1, (Na_1:bitstring, Nb_1:bitstring)))=mess3_1 in
    event eAUTO_IN_TERM_1_0_1_0_1_1_1__S_1( cypher5_1, (Na_1, Nb_1) );
    new Kab_1:bitstring;
    event eServer( idA_1, idB_1, (Kab_1, (Na_1, Nb_1)) );
    event eAUTO_OUT_TERM_2_0_0_0_1_1_1_1__A_2( senc((s2, (idB_1, (Kab_1, (Na_1, Nb_1)))),
                                                    Kas_1)
          );
    out(att,(senc((s2, (idB_1, (Kab_1, (Na_1, Nb_1)))),
                  Kas_1), senc((s3, (idA_1, Kab_1)), Kbs_1))).


process
    !
    (new Kas_1:bitstring;
     new Kbs_1:bitstring;
     out(att,id(Kas_1));
     out(att,id(Kbs_1));
     !
     (((Alice(Kas_1, id(Kas_1), id(Kbs_1)))
     | (!
        (((Bob(Kas_1, Kbs_1, id(Kas_1), id(Kbs_1)))
        | (!
           (Server(Kas_1, Kbs_1, id(Kas_1), id(Kbs_1))))))))))

