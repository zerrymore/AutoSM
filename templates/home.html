{% extends "layout.html"%}
{% block content %}
<!-- Modal -->
<div class="modal fade" id="examples" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
  <div class="modal-dialog  modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="exampleModalLabel">Expert Dataset</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="list-group"></div>
      </div>
    </div>
  </div>
</div>

<!-- <form method="POST"> -->
<div class="row g-3" id="form">
  <div class="col-md-3">
    <div class="input-group">
      <span class="input-group-text" id="models_label">Model:</span>
      <select class="form-control" name="models" id="model_sel" aria-describedby="models_label">
        <option value="code-davinci-002" disabled>Codex (deprecated, code-davinci-002)</option>
        <option value="text-davinci-003">GPT (text-davinci-003)</option>
        <option value="text-bison@001">PaLM (text-bison@001)</option>
        <option value="code-davinci-edit-001">Codex edit (code-davinci-edit-001)</option>
        <option value="gpt-3.5-turbo">GPT Turbo (gpt-3.5-turbo)</option>
        <option value="gpt-3.5-turbo-16k">GPT Turbo 16k (gpt-3.5-turbo-16k)</option>
        <option value="gpt-4">GPT-4</option>
      </select>
    </div>
  </div>
  <div class="col-md-3">
    <div class="input-group">
      <span class="input-group-text" id="num_tries_label">Number of tries:</span>
      <input type="number" id="num_tries" class="form-control" name="num_tries" aria-describedby="num_tries_label"
        value="{{ num_tries }}" max="5" />
    </div>
  </div>

  <div class="col-md-3">
    <div class="input-group">
        <span class="input-group-text" id="protocol_label">Protocol:</span>
        <select class="form-control" name="prompts" id="protocol_sel" aria-describedby="prompts_label">
            <option value="running_ex">running example</option>
            <option value="nsl">Needham-Schroeder Public Key</option>
            <option value="exercise">exercise</option>
            <option value="NAXOS">NAXOS</option>
            <option value="nssk">Needham-Schroeder Symmetric Key</option>
            <option value="or">Otway Rees</option>
            <option value="ssh">SSH</option>
            <option value="LAK06">RFID (LAK'06)</option>
            <option value="X509_1">CCITT X.509</option>
            <option value="ikev2">IKEv2's post-quantum</option>
        </select>
    </div>
</div>

  <div class="col-md-3">
    <div class="field-group"><label class="field-label" style="padding-right: 1em;">Temperature:</label>
      <span id="temp_value"></span>
      <input type="range" class="form-range" step="0.1" value="2" min="0" max="10" id="temperature" name="temperature"
        oninput="setLabel(this)">
    </div>
  </div>

  <div class="col-md-12">
    <div class="widget-tab-contents" id="buttonGroup">
      <input style="float: right; margin-right: 10pt" class="btn-primary" type="submit" , name="repair" ,
        onclick="repairReq()" , value="Repair" />
      <!-- <input style="float: right; margin-right: 10pt" class="btn-primary" type="submit" , name="synthesis" ,
        onclick="synthesisReq()" , value="synthesis" /> -->
      <input style="float: right;margin-right: 10pt" class="btn-primary" type="submit" , name="analysis" ,
        onclick="analysisReq()" , value="analysis" />
      <input style="float: right;margin-right: 10pt" class="btn-primary" type="submit" , name="parse" ,
        onclick="parseReq()" , value="parse" />
    </div>
  </div>
  

  <div class="col-md-12">
    <!-- 1. Diagram  -->
    <div class="widget-tab-contents" id="diagramDivName-container">
      <div id="diagramDivName" style="height:100px; float:left; background-color: #000000"></div>
      <div id="diagramMSC" style="width:40%; height:600px; float:left; background-color: #eee"></div>
      <!-- 1.1 sub-area: loaded texts -->
      <div class="my-text" id="loadtext"
        style="height: 200px; border: 0px solid #030303; overflow-y:scroll;background-color:white;">{{loadText|safe}}
      </div>
      
      <!--
      <div class="editor" id="CodeEditor"
        style="height: 200px; border: 0px solid #000000; background-color:white; overflow-x: auto; overflow-y: scroll;">
      </div>
  
      <div class="my-checkIR" id="sapic"
        style="height: 200px;border: 0px solid #070707;  background-color:white; overflow-x: auto; overflow-y: scroll;">
      </div>
    -->
      <div style="width:60%; float:right;"> <!-- New container for CodeEditor and sapic -->
        <!-- CodeEditor -->
        <div class="editor" id="CodeEditor"
          style="height: 400px; width:48%; border: 0px solid #000000; background-color:white; overflow-x: auto; overflow-y: scroll; float:left;">
          {{initLambda|safe}}
        </div>
      
        <!-- sapic -->
        <div class="my-checkIR" id="sapic"
          style="position: relative; height: 400px; width:52%; border: 2px solid red;  background-color:white; overflow-x: auto; overflow-y: scroll; float:left;">
          <input style="position: absolute; top: 5pt; right: 0px; margin-right: 7pt" class="btn-primary" type="submit" , name="synthesis" ,
        onclick="synthesisReq()" , value="synthesis" />{{initSapic|safe}}
        </div>
      </div>
      
      <div id="InspectorDiv" class="inspector"></div>


    </div>

  </div>
  <!-- </form> -->

  <script src="../static/bundle.js"></script>
  <!-- <script src="https://unpkg.com/gojs/release/go-debug.js"></script> -->
  <script src="../static/go-debug.js"></script>
  <script src="https://www.unpkg.com/jquery@3.6.4/dist/jquery.min.js"></script>
  <script src="https://gojs.net/latest/extensions/DataInspector.js"></script>
  <script>
    function updateEditorContent(newCode) {
      editor = window.myCodeEditor;
      editor.dispatch({
        changes: { from: 0, to: editor.state.doc.length, insert: newCode }
      });
    }

    function parseReq(){
    const parsereq = {
      type: `parse`,
      protocol_sel: document.getElementById("protocol_sel").value,
      model_sel: document.getElementById("model_sel").value
    };
    
    fetch(`${window.location.href}`,{
      method: "POST",  // 可以是 'GET' 或 'POST'
      credentials: "include",
      cache: "no-cache",
      headers: new Headers({ "content-type": "application/json"}),
      body: JSON.stringify(parsereq)
    })
    .then(response => response.json())
        .then(data => {
            console.log('Response from Flask:', data);
            // updateExpr(diagram, data)
            updateEditorContent(data.parseResp);
            document.getElementById("loadtext").innerHTML = data.loadtext;
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error: ' + error.message);
        });
  }

    function repairReq() {
      // var diagram = go.Diagram.fromDiv("diagramDivName");
      // dataNodes = diagram.model.nodeDataArray;
      // var IsGroup = dataNodes.filter(function (dataNode) {
      //   return dataNode.isGroup;
      // });

      const editor = window.myCodeEditor;
      const editorContent = editor.state.doc.toString();

      const repairreq = {
        type: `repair`,
        editorContent: editorContent,
      };
      fetch(`${window.location.href}`, {
        method: "POST",
        credentials: "include",
        cache: "no-cache",
        headers: new Headers({ "content-type": "application/json" }),
        body: JSON.stringify(repairreq)
      })
        .then(response => response.json())
        .then(data => {
          console.log('Response from Flask:', data);
          document.getElementById("sapic").innerHTML = data.code;
          updateEditorContent(data.code_repair);
          // Update the diagram //
        })
        .catch(error => {
          console.error('Error:', error);
          alert('Error: ' + error.message);
        });
    }

    function synthesisReq() {
      var diagram = go.Diagram.fromDiv("diagramMSC");
      dataNodes = diagram.model.nodeDataArray;
      var IsGroup = dataNodes.filter(function (dataNode) {
        return dataNode.isGroup;
      });

      const buttonHtml = `<input style="position: absolute; top: 5px; right: 5px; margin-right: 10pt" class="btn-primary" type="submit" , name="synthesis" ,
        onclick="synthesisReq()" , value="synthesis" />`
      const editor = window.myCodeEditor;
      const editorContent = editor.state.doc.toString();
      console.log(editorContent)
      const synthesisReq = {
        type: `synthesis`,
        editorContent: editorContent,
        protocol_sel: document.getElementById("protocol_sel").value
      };

      fetch(`${window.location.href}`, {
        method: "POST",
        credentials: "include",
        cache: "no-cache",
        headers: new Headers({ "content-type": "application/json" }),
        body: JSON.stringify(synthesisReq)
      })
        .then(response => response.json())
        .then(data => {
          console.log('Response from Flask:', data);
          document.getElementById("sapic").innerHTML = buttonHtml + data.sapic;
          diagram.model = go.Model.fromJson(data.msc)
          // myDiagram.model = go.Model.fromJson(document.getElementById("mySavedModel").value);
        })
        .catch(error => {
          console.error('Error:', error);
          alert('Error: ' + error.message);
        });
    }

    function analysisReq() {
      // var diagram = go.Diagram.fromDiv("diagramDivName");
      // dataNodes = diagram.model.nodeDataArray;
      // var IsGroup = dataNodes.filter(function (dataNode) {
      //   return dataNode.isGroup;
      // });

      const editor = window.myCodeEditor;
      const editorContent = editor.state.doc.toString();
      const analysisreq = {
        type: `analysis`,
        // groups: IsGroup,
        editorContent: editorContent,
      };

      fetch(`${window.location.href}`, {
        method: "POST",
        credentials: "include",
        cache: "no-cache",
        headers: new Headers({ "content-type": "application/json" }),
        body: JSON.stringify(analysisreq)
      })
        .then(response => response.json())
        .then(data => {
          console.log('Response from Flask:', data);
          // document.getElementById("checkIR").innerHTML = data;
          updateEditorContent(data)
        })
        .catch(error => {
          console.error('Error:', error);
          alert('Error: ' + error.message);
        });
    }

    function debug(message) {
      $('#debug').html(message);
    }

    function debug_obj(obj) {
      $('#debug').html(JSON.stringify(obj));
    }
  </script>
 
  <script>
    function loadMSC(name, mscJson) {

      // Since 2.2 you can also author concise templates with method chaining instead of GraphObject.make
      // For details, see https://gojs.net/latest/intro/buildingObjects.html
      const $$ = go.GraphObject.make;

      const myDiagram =
        $$(go.Diagram, name, // must be the ID or reference to an HTML DIV
          {
            allowCopy: false,
            linkingTool: $$(MessagingTool),  // defined below
            "resizingTool.isGridSnapEnabled": true,
            draggingTool: $$(MessageDraggingTool),  // defined below
            "draggingTool.gridSnapCellSize": new go.Size(1, MessageSpacing / 4),
            "draggingTool.isGridSnapEnabled": true,
            // automatically extend Lifelines as Activities are moved or resized
            "SelectionMoved": ensureLifelineHeights,
            "PartResized": ensureLifelineHeights,
            "undoManager.isEnabled": true
          });

      function ensureLifelineHeights(e) {
        // iterate over all Activities (ignore Groups)
        const arr = myDiagram.model.nodeDataArray;
        let max = -1;
        for (let i = 0; i < arr.length; i++) {
          const act = arr[i];
          if (act.isGroup) continue;
          max = Math.max(max, act.start + act.duration);
        }
        if (max > 0) {
          // now iterate over only Groups
          for (let i = 0; i < arr.length; i++) {
            const gr = arr[i];
            if (!gr.isGroup) continue;
            if (max > gr.duration) {  // this only extends, never shrinks
              myDiagram.model.setDataProperty(gr, "duration", max);
            }
          }
        }
      }
      // when the document is modified, add a "*" to the title and enable the "Save" button

      function computeActivityLocation(act) {
        const groupdata = myDiagram.model.findNodeDataForKey(act.group);
        if (groupdata === null) return new go.Point();
        // get location of Lifeline's starting point
        const grouploc = go.Point.parse(groupdata.loc);
        return new go.Point(grouploc.x, convertTimeToY(act.start) - ActivityStart);
      }
      myDiagram.addDiagramListener("Modified", e => {
        const button = document.getElementById("SaveButton");
        if (button) button.disabled = !myDiagram.isModified;
        const idx = document.title.indexOf("*");
        if (myDiagram.isModified) {
          if (idx < 0) document.title += "*";
        } else {
          if (idx >= 0) document.title = document.title.slice(0, idx);
        }
      });

      // define the Lifeline Node template.
      myDiagram.groupTemplate =
        $$(go.Group, "Vertical",
          {
            locationSpot: go.Spot.Bottom,
            locationObjectName: "HEADER",
            minLocation: new go.Point(0, 0),
            maxLocation: new go.Point(9999, 0),
            selectionObjectName: "HEADER"
          },
          new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
          $$(go.Panel, "Auto",
            { name: "HEADER" },
            $$(go.Shape, "Rectangle",
              {
                fill: $$(go.Brush, "Linear", { 0: "#bbdefb", 1: go.Brush.darkenBy("#bbdefb", 0.1) }),
                width: 80,
                stroke: null
              }),
            $$(go.TextBlock,
              {
                margin: 5,
                font: "400 10pt Source Sans Pro, sans-serif"
              },
              new go.Binding("text", "text"))
          ),
          $$(go.Shape,
            {
              figure: "LineV",
              fill: null,
              stroke: "gray",
              // strokeDashArray: [3, 3],
              width: 1,
              alignment: go.Spot.Center,
              portId: "",
              fromLinkable: true,
              fromLinkableDuplicates: true,
              toLinkable: true,
              toLinkableDuplicates: true,
              cursor: "pointer"
            },
            new go.Binding("height", "duration", computeLifelineHeight)),
          $$(go.Panel, "Auto",
            { name: "HEADER" },
            $$(go.Shape, "Rectangle",
              {
                fill: "black",
                width: 60, height: 8,
                stroke: null,
              }),
          )
        );

      // define the Activity Node template
      myDiagram.nodeTemplate =
        $$(go.Node,
          {
            locationSpot: go.Spot.Top,
            locationObjectName: "SHAPE",
            minLocation: new go.Point(NaN, LinePrefix - ActivityStart),
            maxLocation: new go.Point(NaN, 19999),
            selectionObjectName: "SHAPE",
            resizable: true,
            resizeObjectName: "SHAPE",
            resizeAdornmentTemplate:
              $$(go.Adornment, "Spot",
                $$(go.Placeholder),
                $$(go.Shape,  // only a bottom resize handle
                  {
                    alignment: go.Spot.Bottom, cursor: "col-resize",
                    desiredSize: new go.Size(6, 6), fill: "yellow"
                  })
              )
          },
          new go.Binding("location", "", computeActivityLocation).makeTwoWay(backComputeActivityLocation),
          // $$(go.Shape, "Rectangle",
          //   {
          //     name: "SHAPE",
          //     fill: "white", stroke: "black",
          //     width: ActivityWidth,
          //     // allow Activities to be resized down to 1/4 of a time unit
          //     minSize: new go.Size(ActivityWidth, computeActivityHeight(0.25))
          //   },
          //   new go.Binding("height", "duration", computeActivityHeight).makeTwoWay(backComputeActivityHeight)),
          $$(go.Panel, "Auto",
            $$(go.Shape, "Rectangle", // This Shape acts as the border
              {
                fill: "white",
                stroke: "blue", // Border color
                strokeWidth: 1, // Reduced border thickness
                strokeDashArray: [4, 2] // Adjusted dash pattern for a finer appearance
              },
              new go.Binding("height", "duration", computeActivityHeight).makeTwoWay(backComputeActivityHeight)),
            $$(go.TextBlock,
              {
                margin: 3, // Ensure some spacing between text and border
                // Other TextBlock properties here
                background: "white",
                font: "8pt  Source Sans Pro",
              },
              new go.Binding("text", "text"),
            )
          )

        );

      // define the Message Link template.
      myDiagram.linkTemplate =
        $$(MessageLink,  // defined below
          { selectionAdorned: true, curviness: 0 },
          $$(go.Shape, "Rectangle",
            { stroke: "#DC143C" }),
          $$(go.Shape,
            { toArrow: "Standard", stroke: "#DC143C", fill: "#DC143C" }),
          $$(go.TextBlock,
            {
              font: "400 9pt Source Sans Pro, sans-serif",
              segmentIndex: 0,
              segmentOffset: new go.Point(NaN, NaN),
              isMultiline: false,
              editable: true
            },
            new go.Binding("text", "text").makeTwoWay())
        );

      // create the graph by reading the JSON data saved in "mySavedModel" textarea element
      myDiagram.model = go.Model.fromJson(mscJson);
    }


    // some parameters
    const LinePrefix = 18;  // vertical starting point in document for all Messages and Activations
    const LineSuffix = 20;  // vertical length beyond the last message time
    const MessageSpacing = 22;  // vertical distance between Messages at different steps
    const ActivityWidth = 10;  // width of each vertical activity bar
    const ActivityStart = 5;  // height before start message time
    const ActivityEnd = 5;  // height beyond end message time

    function computeLifelineHeight(duration) {
      return LinePrefix + duration * MessageSpacing + LineSuffix;
    }

    function backComputeActivityLocation(loc, act) {
      myDiagram.model.setDataProperty(act, "start", convertYToTime(loc.y + ActivityStart));
    }

    function computeActivityHeight(duration) {
      return ActivityStart + duration * MessageSpacing + ActivityEnd;
    }
    function backComputeActivityHeight(height) {
      return (height - ActivityStart - ActivityEnd) / MessageSpacing;
    }

    // time is just an abstract small non-negative integer
    // here we map between an abstract time and a vertical position
    function convertTimeToY(t) {
      return t * MessageSpacing + LinePrefix;
    }
    function convertYToTime(y) {
      return (y - LinePrefix) / MessageSpacing;
    }


    // a custom routed Link
    class MessageLink extends go.Link {
      constructor() {
        super();
        this.time = 0;  // use this "time" value when this is the temporaryLink
      }

      getLinkPoint(node, port, spot, from, ortho, othernode, otherport) {
        const p = port.getDocumentPoint(go.Spot.Center);
        const r = port.getDocumentBounds();
        const op = otherport.getDocumentPoint(go.Spot.Center);

        const data = this.data;
        const time = data !== null ? data.time : this.time;  // if not bound, assume this has its own "time" property

        const aw = this.findActivityWidth(node, time);
        const x = (op.x > p.x ? p.x + aw / 2 : p.x - aw / 2);
        const y = convertTimeToY(time);
        return new go.Point(x, y);
      }

      findActivityWidth(node, time) {
        let aw = ActivityWidth;
        if (node instanceof go.Group) {
          // see if there is an Activity Node at this point -- if not, connect the link directly with the Group's lifeline
          if (!node.memberParts.any(mem => {
            const act = mem.data;
            return (act !== null && act.start <= time && time <= act.start + act.duration);
          })) {
            aw = 0;
          }
        }
        return aw;
      }

      getLinkDirection(node, port, linkpoint, spot, from, ortho, othernode, otherport) {
        const p = port.getDocumentPoint(go.Spot.Center);
        const op = otherport.getDocumentPoint(go.Spot.Center);
        const right = op.x > p.x;
        return right ? 0 : 180;
      }

      computePoints() {
        if (this.fromNode === this.toNode) {  // also handle a reflexive link as a simple orthogonal loop
          const data = this.data;
          const time = data !== null ? data.time : this.time;  // if not bound, assume this has its own "time" property
          const p = this.fromNode.port.getDocumentPoint(go.Spot.Center);
          const aw = this.findActivityWidth(this.fromNode, time);

          const x = p.x + aw / 2;
          const y = convertTimeToY(time);
          this.clearPoints();
          this.addPoint(new go.Point(x, y));
          this.addPoint(new go.Point(x + 50, y));
          this.addPoint(new go.Point(x + 50, y + 5));
          this.addPoint(new go.Point(x, y + 5));
          return true;
        } else {
          return super.computePoints();
        }
      }
    }
    // end MessageLink


    // A custom LinkingTool that fixes the "time" (i.e. the Y coordinate)
    // for both the temporaryLink and the actual newly created Link
    class MessagingTool extends go.LinkingTool {
      constructor() {
        super();

        // Since 2.2 you can also author concise templates with method chaining instead of GraphObject.make
        // For details, see https://gojs.net/latest/intro/buildingObjects.html
        const $$ = go.GraphObject.make;
        this.temporaryLink =
          $$(MessageLink,
            $$(go.Shape, "Rectangle",
              { stroke: "magenta", strokeWidth: 2 }),
            $$(go.Shape,
              { toArrow: "OpenTriangle", stroke: "magenta" }));
      }

      doActivate() {
        super.doActivate();
        const time = convertYToTime(this.diagram.firstInput.documentPoint.y);
        this.temporaryLink.time = Math.ceil(time);  // round up to an integer value
      }

      insertLink(fromnode, fromport, tonode, toport) {
        const newlink = super.insertLink(fromnode, fromport, tonode, toport);
        if (newlink !== null) {
          const model = this.diagram.model;
          // specify the time of the message
          const start = this.temporaryLink.time;
          const duration = 1;
          newlink.data.time = start;
          model.setDataProperty(newlink.data, "text", "msg");
          // and create a new Activity node data in the "to" group data
          const newact = {
            group: newlink.data.to,
            start: start,
            duration: duration
          };
          model.addNodeData(newact);
          // now make sure all Lifelines are long enough
          ensureLifelineHeights();
        }
        return newlink;
      }
    }
    // end MessagingTool


    // A custom DraggingTool that supports dragging any number of MessageLinks up and down --
    // changing their data.time value.
    class MessageDraggingTool extends go.DraggingTool {
      // override the standard behavior to include all selected Links,
      // even if not connected with any selected Nodes
      computeEffectiveCollection(parts, options) {
        const result = super.computeEffectiveCollection(parts, options);
        // add a dummy Node so that the user can select only Links and move them all
        result.add(new go.Node(), new go.DraggingInfo(new go.Point()));
        // normally this method removes any links not connected to selected nodes;
        // we have to add them back so that they are included in the "parts" argument to moveParts
        parts.each(part => {
          if (part instanceof go.Link) {
            result.add(part, new go.DraggingInfo(part.getPoint(0).copy()));
          }
        })
        return result;
      }

      // override to allow dragging when the selection only includes Links
      mayMove() {
        return !this.diagram.isReadOnly && this.diagram.allowMove;
      }

      // override to move Links (which are all assumed to be MessageLinks) by
      // updating their Link.data.time property so that their link routes will
      // have the correct vertical position
      moveParts(parts, offset, check) {
        super.moveParts(parts, offset, check);
        const it = parts.iterator;
        while (it.next()) {
          if (it.key instanceof go.Link) {
            const link = it.key;
            const startY = it.value.point.y;  // DraggingInfo.point.y
            let y = startY + offset.y;  // determine new Y coordinate value for this link
            const cellY = this.gridSnapCellSize.height;
            y = Math.round(y / cellY) * cellY;  // snap to multiple of gridSnapCellSize.height
            const t = Math.max(0, convertYToTime(y));
            link.diagram.model.set(link.data, "time", t);
            link.invalidateRoute();
          }
        }
      }
    }
    // end MessageDraggingTool


    // Show the diagram's model in JSON format
    // function load() {
    //     myDiagram.model = go.Model.fromJson(document.getElementById("mySavedModel").value);
    // }

    data = {
      "class": "go.GraphLinksModel",
      "nodeDataArray": [
        { "key": "Fred", "text": "Fred: Patron", "isGroup": true, "loc": "0 0", "duration": 7 },
        { "key": "Bob", "text": "Bob: Waiter", "isGroup": true, "loc": "100 0", "duration": 7 },
        { "key": "Hank", "text": "Hank: Cook", "isGroup": true, "loc": "200 0", "duration": 7 },
        { "key": "Renee", "text": "Renee: Cashier", "isGroup": true, "loc": "300 0", "duration": 7 },
        { "group": "Bob", "start": 2, "duration": 1, "text": "hello\nhelloKFSAD" },
        { "group": "Hank", "start": 2, "duration": 0 },
        { "group": "Fred", "start": 3, "duration": 0 },
        { "group": "Bob", "start": 5, "duration": 0 },
        { "group": "Fred", "start": 6, "duration": 0 },
        { "group": "Renee", "start": 8, "duration": 0 }
      ],
      "linkDataArray": [
        { "from": "Fred", "to": "Bob", "text": "order\norder", "time": 1 },
        { "from": "Bob", "to": "Hank", "text": "order food", "time": 2 },
        { "from": "Bob", "to": "Fred", "text": "serve drinks", "time": 3 },
        { "from": "Hank", "to": "Bob", "text": "finish cooking", "time": 5 },
        { "from": "Bob", "to": "Fred", "text": "serve food", "time": 6 },
        { "from": "Fred", "to": "Renee", "text": "pay", "time": 8 }
      ]
    };
    window.addEventListener('DOMContentLoaded', loadMSC('diagramMSC', data));

    document.getElementById('protocol_sel').addEventListener('change', function() {
      var content = document.getElementById('loadtext');
      var selectedOption = this.options[this.selectedIndex].value;
      console.log(selectedOption);
      switch(selectedOption) {
          case 'running_ex':
              content.innerHTML = `<div class="highlight"><pre><span></span><span id="True-1"><a id="line-1" name="line-1"></a><span class="linenos">1</span>In this protocol, a client C generates a fresh symmetric key k, encrypts it with the public key pkS of a server S (aenc stands for asymmetric encryption),
</span><span id="True-2"><a id="line-2" name="line-2"></a><span class="linenos">2</span>and sends it to S. The server confirms the key&#39;s receipt by sending the hash of the key back to the client.
</span></pre></div>`;
              break;
          case 'nsl':
              content.innerHTML = `<div class="highlight"><pre><span></span><span id="True-1"><a id="line-1" name="line-1"></a><span class="linenos">1</span>Alice starts the protocol by sending her identity A together with a freshly generated random number Na. 
</span><span id="True-2"><a id="line-2" name="line-2"></a><span class="linenos">2</span>This message is encrypted using an asymmetric encryption algorithm with B&#39;s public key (denoted pub(B)).
</span><span id="True-3"><a id="line-3" name="line-3"></a><span class="linenos">3</span>We suppose that only agent Bob (whose identity is B) knows the secret key corresponding to pub(B).
</span><span id="True-4"><a id="line-4" name="line-4"></a><span class="linenos">4</span>Next Bob receives the message {A, Na}pub(B) sent by Alice. Using his private key, Bob decrypts the message. 
</span><span id="True-5"><a id="line-5" name="line-5"></a><span class="linenos">5</span>He sends the received nonce Na together with a freshly generated nonce Nb encrypted with A&#39;s public key (pub(A)) to Alice.
</span><span id="True-6"><a id="line-6" name="line-6"></a><span class="linenos">6</span>Finally Alice receives the message {Na, Nb}pub(A). 
</span><span id="True-7"><a id="line-7" name="line-7"></a><span class="linenos">7</span>She decrypts the message and checks that the nonce NA corresponds to the nonce previously generated and sent to Bob.
</span><span id="True-8"><a id="line-8" name="line-8"></a><span class="linenos">8</span>She sends the nonce Nb to Bob encrypted with Bob&#39;s public key.
</span><span id="True-9"><a id="line-9" name="line-9"></a><span class="linenos">9</span>Upon reception of this message Bob decrypts it and checks that the nonce corresponds to the one previously generated.
</span></pre></div>`;
              break;
          // 添加更多选项的处理
          case 'exercise':
            content.innerHTML = `<div class="highlight"><pre><span></span><span id="True-1"><a id="line-1" name="line-1"></a><span class="linenos">1</span>Alex computes a nonce and sends it to Blake. (A -&gt; B: ANonce)
</span><span id="True-2"><a id="line-2" name="line-2"></a><span class="linenos">2</span>When Blake receives Alex&#39;s nonce, Blake computes their own nonce and sends it to Alex. (B -&gt; A: BNonce)
</span><span id="True-3"><a id="line-3" name="line-3"></a><span class="linenos">3</span>When Alex receives Blake&#39;s nonce, Alex does two things:
</span><span id="True-4"><a id="line-4" name="line-4"></a><span class="linenos">4</span>Alex installs a session key SK, which is derived from ANonce and BNonce by applying a key derivation function (i.e., SK = kdf(ANonce, BNonce)).
</span><span id="True-5"><a id="line-5" name="line-5"></a><span class="linenos">5</span>Once the session key is installed, Alex sends a message with the string &quot;ACK&quot; to Blake (A -&gt; B: &quot;ACK&quot;) and switches to a &#39;DONE&#39; state to indicate that the protocol has been executed successfully on Alex&#39;s side.
</span><span id="True-6"><a id="line-6" name="line-6"></a><span class="linenos">6</span>When Blake receives the &quot;ACK&quot; message, Blake also computes the session key SK = kdf(ANonce, BNonce), installs it and switches to a &#39;DONE&#39; state.
</span></pre></div>`;
            break;
          case 'NAXOS':
            content.innerHTML = `<div class="highlight"><pre><span></span><span id="True-1"><a id="line-1" name="line-1"></a><span class="linenos">1</span>In this protocol, each party x has a long-term private key lkx and a corresponding public key pkx = &#39;g&#39;^lkx,
</span><span id="True-2"><a id="line-2" name="line-2"></a><span class="linenos">2</span>where &#39;g&#39; is a generator of the Diffie-Hellman group. Because &#39;g&#39; can be public, we model it as a public constant.
</span><span id="True-3"><a id="line-3" name="line-3"></a><span class="linenos">3</span>Two different hash functions h1 and h2 are used.
</span><span id="True-4"><a id="line-4" name="line-4"></a><span class="linenos">4</span>
</span><span id="True-5"><a id="line-5" name="line-5"></a><span class="linenos">5</span>To start a session, the initiator I first creates a fresh nonce eskI, also known as I&#39;s ephemeral (private) key.
</span><span id="True-6"><a id="line-6" name="line-6"></a><span class="linenos">6</span>He then concatenates eskI with I&#39;s long-term private key lkI, hashes the result using the hash function h1, and sends &#39;g&#39;^h1(eskI ,lkI) to the responder.
</span><span id="True-7"><a id="line-7" name="line-7"></a><span class="linenos">7</span>The responder R stores the received value <span class="nf">in</span> a variable X, computes a similar value based on his own nonce eskR and long-term private key lkR, and sends the result to the initiator, who stores the received value <span class="nf">in</span> the variable Y.
</span><span id="True-8"><a id="line-8" name="line-8"></a><span class="linenos">8</span>Finally, both parties compute a session key (kI and kR, respectively) whose computation includes their own long-term private keys, such that only the intended partner can compute the same key.
</span></pre></div>`;
            break;
          case 'nssk':
            content.innerHTML = `<div class="highlight"><pre><span></span><span id="True-1"><a id="line-1" name="line-1"></a><span class="linenos">1</span>A sends a message containing A&#39;s identity, B&#39;s identity, and a nonce value Na to S.
</span><span id="True-2"><a id="line-2" name="line-2"></a><span class="linenos">2</span>S sends a message to A containing several components encrypted with Kas. These components include Na, B&#39;s identity, a shared secret key Kab, and an encrypted message containing Kab and A&#39;s identity encrypted with Kbs.
</span><span id="True-3"><a id="line-3" name="line-3"></a><span class="linenos">3</span>A sends a message to B containing Kab and A&#39;s identity, encrypted with Kbs.
</span><span id="True-4"><a id="line-4" name="line-4"></a><span class="linenos">4</span>B sends a message to A containing a nonce value Nb, encrypted with Kab.
</span><span id="True-5"><a id="line-5" name="line-5"></a><span class="linenos">5</span>A sends a message to B containing the decryption of Nb using Kab, encrypted with Kab.
</span></pre></div>`
            break; 
          case 'or':
          content.innerHTML = `<div class="highlight"><pre><span></span><span id="True-1"><a id="line-1" name="line-1"></a><span class="linenos">1</span>A initiates communication with B by sending a message containing M (a nonce), A&#39;s identity, B&#39;s identity, and an encrypted portion {Na, M, A, B}Kas using A&#39;s secret key Kas.
</span><span id="True-2"><a id="line-2" name="line-2"></a><span class="linenos">2</span>B receives the message from A and responds by sending back a message that includes M, A&#39;s identity, B&#39;s identity, the previously received encrypted portion {Na, M, A, B}Kas, and another encrypted portion {Nb, M, A, B}Kbs using B&#39;s secret key Kbs.
</span><span id="True-3"><a id="line-3" name="line-3"></a><span class="linenos">3</span>The server S receives the message from B and forwards it to B. S decrypts the first encrypted portion {Na, M, A, B}Kas and {Nb, M, A, B}Kbs, obtaining Na and Nb. 
</span><span id="True-4"><a id="line-4" name="line-4"></a><span class="linenos">4</span>Then S re-encrypts Na with the shared secret key Kab to create {Na, Kab}Kas and re-encrypts Nb with the same shared key Kab to create {Nb, Kab}Kbs.
</span><span id="True-5"><a id="line-5" name="line-5"></a><span class="linenos">5</span>S sends this modified message to B.
</span><span id="True-6"><a id="line-6" name="line-6"></a><span class="linenos">6</span>B receives the modified message from S, decrypts the encrypted portions {Na, Kab}Kas and {Nb, Kab}Kbs, obtaining Na and Kab.
</span><span id="True-7"><a id="line-7" name="line-7"></a><span class="linenos">7</span>B then re-encrypts Na with the shared secret key Kab to create {Na, Kab}Kas and sends this to A.        
</span></pre></div>`
            break; 
          case 'ssh':
            content.innerHTML = `<div class="highlight"><pre><span></span><span id="True-1"><a id="line-1" name="line-1"></a><span class="linenos"> 1</span>The following steps are used to exchange a key.  In this, C is the
</span><span id="True-2"><a id="line-2" name="line-2"></a><span class="linenos"> 2</span>client; S is the server; p is a large safe prime; g is a generator
</span><span id="True-3"><a id="line-3" name="line-3"></a><span class="linenos"> 3</span>for a subgroup of GF(p); q is the order of the subgroup; V_S is S&#39;s
</span><span id="True-4"><a id="line-4" name="line-4"></a><span class="linenos"> 4</span>identification string; V_C is C&#39;s identification string; K_S is S&#39;s
</span><span id="True-5"><a id="line-5" name="line-5"></a><span class="linenos"> 5</span>public host key; I_C is C&#39;s SSH_MSG_KEXINIT message and I_S is S&#39;s
</span><span id="True-6"><a id="line-6" name="line-6"></a><span class="linenos"> 6</span>SSH_MSG_KEXINIT message that have been exchanged before this part
</span><span id="True-7"><a id="line-7" name="line-7"></a><span class="linenos"> 7</span>begins.
</span><span id="True-8"><a id="line-8" name="line-8"></a><span class="linenos"> 8</span>
</span><span id="True-9"><a id="line-9" name="line-9"></a><span class="linenos"> 9</span>C generates a random number x (1 &lt; x &lt; q) and computes
</span><span id="True-10"><a id="line-10" name="line-10"></a><span class="linenos">10</span>e = g^x mod p.  C sends e to S.
</span><span id="True-11"><a id="line-11" name="line-11"></a><span class="linenos">11</span>
</span><span id="True-12"><a id="line-12" name="line-12"></a><span class="linenos">12</span>S generates a random number y (0 &lt; y &lt; q) and computes
</span><span id="True-13"><a id="line-13" name="line-13"></a><span class="linenos">13</span>f = g^y mod p.  S receives e.  It computes K = e^y mod p,
</span><span id="True-14"><a id="line-14" name="line-14"></a><span class="linenos">14</span>H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K)
</span><span id="True-15"><a id="line-15" name="line-15"></a><span class="linenos">15</span>(these elements are encoded according to their types; see below),
</span><span id="True-16"><a id="line-16" name="line-16"></a><span class="linenos">16</span>and signature s on H with its private host key.  S sends
</span><span id="True-17"><a id="line-17" name="line-17"></a><span class="linenos">17</span>(K_S || f || s) to C.  The signing operation may involve a
</span><span id="True-18"><a id="line-18" name="line-18"></a><span class="linenos">18</span>second hashing operation.
</span><span id="True-19"><a id="line-19" name="line-19"></a><span class="linenos">19</span>
</span><span id="True-20"><a id="line-20" name="line-20"></a><span class="linenos">20</span>C verifies that K_S really is the host key for S (e.g., using
</span><span id="True-21"><a id="line-21" name="line-21"></a><span class="linenos">21</span>certificates or a local database).  C is also allowed to accept
</span><span id="True-22"><a id="line-22" name="line-22"></a><span class="linenos">22</span>the key without verification; however, doing so will render the
</span><span id="True-23"><a id="line-23" name="line-23"></a><span class="linenos">23</span>protocol insecure against active attacks (but may be desirable for
</span><span id="True-24"><a id="line-24" name="line-24"></a><span class="linenos">24</span>practical reasons <span class="nf">in</span> the short term <span class="nf">in</span> many environments).  C then
</span><span id="True-25"><a id="line-25" name="line-25"></a><span class="linenos">25</span>computes K = f^x mod p, H = hash(V_C || V_S || I_C || I_S || K_S
</span><span id="True-26"><a id="line-26" name="line-26"></a><span class="linenos">26</span>|| e || f || K), and verifies the signature s on H.
</span></pre></div>`;
            break;
          case 'LAK06':
            content.innerHTML = `<div class="highlight"><pre><span></span><span id="True-1"><a id="line-1" name="line-1"></a><span class="linenos"> 1</span>R: knows(k, k0)
</span><span id="True-2"><a id="line-2" name="line-2"></a><span class="linenos"> 2</span>T: knows(k)
</span><span id="True-3"><a id="line-3" name="line-3"></a><span class="linenos"> 3</span>R: fresh(r0)
</span><span id="True-4"><a id="line-4" name="line-4"></a><span class="linenos"> 4</span>1. R -&gt; T: r0
</span><span id="True-5"><a id="line-5" name="line-5"></a><span class="linenos"> 5</span>T: fresh(r1)
</span><span id="True-6"><a id="line-6" name="line-6"></a><span class="linenos"> 6</span>2. T -&gt; R: r1, h(r0 xor r1 xor k)
</span><span id="True-7"><a id="line-7" name="line-7"></a><span class="linenos"> 7</span>R: updates k0 := k
</span><span id="True-8"><a id="line-8" name="line-8"></a><span class="linenos"> 8</span>R: updates k := h(k)
</span><span id="True-9"><a id="line-9" name="line-9"></a><span class="linenos"> 9</span>3. R -&gt; T: h(h(r0 xor r1 xor k) xor k xor r0)
</span><span id="True-10"><a id="line-10" name="line-10"></a><span class="linenos">10</span>T: updates k := h(k)
</span></pre></div>`;
            break;
          default:
              content.innerHTML = '<p>Choose an option</p>';
      }
});
  </script>

  {% endblock %}