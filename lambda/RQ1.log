//*== NSPK == *//
/*
Alice starts the protocol by sending her identity A together with a freshly generated random number Na.
This message is encrypted using an asymmetric encryption algorithm with B's public key (denoted pub(B)). 
We suppose that only agent Bob (whose identity is B) knows the secret key corresponding to pub(B).

Next Bob receives the message {A, Na}pub(B) sent by Alice. Using his private key, Bob decrypts
the message. He sends the received nonce Na together with a freshly generated nonce Nb
encrypted with A's public key (pub(A)) to Alice.

Finally Alice receives the message {Na, Nb}pub(A). She decrypts the message and checks that
the nonce NA corresponds to the nonce previously generated and sent to Bob. She sends
the nonce Nb to Bob encrypted with Bob's public key. Upon reception of this message Bob
decrypts it and checks that the nonce corresponds to the one previously generated.
*/


//*== NAXOS == *//
/*
In this protocol, each party x has a long-term private key lkx and a corresponding public key 
pkx = 'g'^lkx, where 'g' is a generator of the Diffie-Hellman group. Because 'g' can be public, 
we model it as a public constant. Two different hash functions h1 and h2 are used.

To start a session, the initiator I first creates a fresh nonce eskI, 
also known as I's ephemeral (private) key. He then concatenates eskI with I's long-term private key lkI,
hashes the result using the hash function h1, and sends 'g'^h1(eskI ,lkI) to the responder. 

The responder R stores the received value in a variable X, 
computes a similar value based on his own nonce eskR and long-term private key lkR, 
and sends the result to the initiator, who stores the received value in the variable Y. 

Finally, both parties compute a session key (kI and kR, respectively) 
whose computation includes their own long-term private keys, such that only the intended partner can compute the same key.
*/


//*== Otway-Rees == *//
/*
The Otway-Rees Protocol makes it possible to distribute a session key kab created 
by the trusted server S to two principals A and B. This key will encrypt the information 
transmitted between these two principals

1. A sends B the protocol session number, his identity, the identity of the principal
with whom he wishes to communicate, and a message encrypted with the key `kas`, i.e.,
the message1 is `I,A,B,{Na,I,A,B}kas`.

2. B receives A's message and adds his own message encrypted with the key kbs before 
sending it to the trusted server S. (message2=`I,A,B,{Na,I,A,B}kas,{Nb,I,A,B}kbs`)

3. S receives the message and is able to retrieve the session number, the random number 
from A: `Na`, using his shared key kas, the random number from B: `Nb` with the other shared 
key `kbs`, and generates the session key `kab`. With this information, he is able to generate
message 3 and sends it to B. message3=`{Na,kab}kas,{Nb, kab}kbs`

4. The principal in question receives message 3, removes the last encrypted part with his 
shared key, decrypts this sub-message with his key `kbs`, retrieves the session key `kab`, 
and sends the remaining part of the message to A. In this way, A is also able to 
retrieve the session key kab, based on the last part of message 4 (`I,{Na,kab}kas`),
by using his shared key kas, and the two principals are able to start communicating. 

*/

//*== SSH == *//
/*
The Diffie-Hellman (DH) key exchange provides a shared secret that
cannot be determined by either party alone.  The key exchange is
combined with a signature with the host key to provide host
authentication.  This key exchange method provides explicit server
authentication as defined in Section 7.

The following steps are used to exchange a key.  In this, C is the
client; S is the server; p is a large safe prime; g is a generator
for a subgroup of GF(p); q is the order of the subgroup; V_S is S's
identification string; V_C is C's identification string; K_S is S's
public host key; I_C is C's SSH_MSG_KEXINIT message and I_S is S's
SSH_MSG_KEXINIT message that have been exchanged before this part
begins.

1. C generates a random number x (1 < x < q) and computes
    e = g^x mod p.  C sends e to S.

2. S generates a random number y (0 < y < q) and computes
    f = g^y mod p.  S receives e.  It computes K = e^y mod p,
    H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K)
    (these elements are encoded according to their types; see below),
    and signature s on H with its private host key.  S sends
    (K_S || f || s) to C.  The signing operation may involve a
    second hashing operation.

3. C verifies that K_S really is the host key for S (e.g., using
    certificates or a local database).  C is also allowed to accept
    the key without verification; however, doing so will render the
    protocol insecure against active attacks (but may be desirable for
    practical reasons in the short term in many environments).  C then
    computes K = f^x mod p, H = hash(V_C || V_S || I_C || I_S || K_S
    || e || f || K), and verifies the signature s on H.

Values of 'e' or 'f' that are not in the range [1, p-1] MUST NOT be
sent or accepted by either side.  If this condition is violated, the
key exchange fails.

This is implemented with the following messages.  The hash algorithm
for computing the exchange hash is defined by the method name, and is
called HASH.  The public key algorithm for signing is negotiated with
the SSH_MSG_KEXINIT messages.


The key exchange produces two values: a shared secret K, and an
exchange hash H.  Encryption and authentication keys are derived from
these.  The exchange hash H from the first key exchange is
additionally used as the session identifier, which is a unique
identifier for this connection.  It is used by authentication methods
as a part of the data that is signed as a proof of possession of a
private key.  Once computed, the session identifier is not changed,
even if keys are later re-exchanged.

Each key exchange method specifies a hash function that is used in
the key exchange.  The same hash algorithm MUST be used in key
derivation.  Here, we'll call it HASH.

Encryption keys MUST be computed as HASH, of a known value and K, as
follows:

o  Initial IV client to server: HASH(K || H || "A" || session_id)
    (Here K is encoded as mpint and "A" as byte and session_id as raw
    data.  "A" means the single character A, ASCII 65).

o  Initial IV server to client: HASH(K || H || "B" || session_id)

o  Encryption key client to server: HASH(K || H || "C" || session_id)

o  Encryption key server to client: HASH(K || H || "D" || session_id)

o  Integrity key client to server: HASH(K || H || "E" || session_id)

o  Integrity key server to client: HASH(K || H || "F" || session_id)

Key data MUST be taken from the beginning of the hash output.  As
many bytes as needed are taken from the beginning of the hash value.
If the key length needed is longer than the output of the HASH, the
key is extended by computing HASH of the concatenation of K and H and
the entire key so far, and appending the resulting bytes (as many as
HASH generates) to the key.  This process is repeated until enough
key material is available; the key is taken from the beginning of
this value.  In other words:
*/


//*== KEMTLS == *//
/*
There are conceptually three phases to KEMTLS, each of which
establishes one or more “stage” keys.
Phase 1: Ephemeral key exchange using KEMs. 
After establishing the TCP connection, 
the KEMTLS handshake begins with the client sending one or more ephemeral KEM public keys pke
in its 'ClientHello' message, as well as the list of public key authentication, key exchange, 
and authenticated encryption methods it supports. 

The server responds in the 'ServerHello' message
with an encapsulation cte against pke and the algorithms it selected from the client's proposal; 
note that if (none of) the pke the client sent was for the key-exchange method the server selected,
a special HelloRetryRequest message is sent, prompting a new 'ClientHello' message.
Nonces rc and rs are also transmitted for freshness.

At this point, the client and server have an unauthenticated shared secret sse.
KEMTLS follows the TLS 1.3 key schedule, which applies a sequence of HKDF operations to the shared secret sse 
and the transcript to derive (a) the client and server handshake traffic secrets CHTS and SHTS 
which are used to encrypt subsequent flows in the handshake, and (b) a "derived handshake secret" dHS
which is kept as the current secret state of the key schedule.

Phase 2: Implicitly authenticated key exchange using KEMs.
In the same server-to-client flight as 'ServerHello', 
the server also sends a certificate containing its long-term KEM public key pks.
The client encapsulates against pks and sends the resulting ciphertext in its 'ClientKemCiphertext' message. 
This yields an implicitly authenticated shared secret ssS.
The key schedule's secret state dHS from phase 1 is combined with ssS using HKDF 
to give an "authenticated handshake secret" AHS from which are derived 
(c) the client and server authenticated handshake traffic secrets CAHTS and SAHTS 
which are used to encrypt subsequent flows in the handshake, 
and (d) an updated secret state dAHS of the key schedule. 
A master secret MS can now be derived from the key schedule's secret state dAHS. 
From the master secret, several more keys are derived: 
(e) "finished keys" fkc and fks which will be used to authenticate the handshake 
and (f) client and server application transport secrets CATS and SATS 
from which are derived application encryption keys. 
The client now sends a confirmation message 'ClientFinished' to the server 
which uses a message authentication code with key fkc to authenticate the handshake transcript. 
In the same flight of messages, 
the client is also able to start sending application data encrypted under keys derived from CATS; 
this is implicitly authenticated.

Phase 3: Confirmation / explicit authentication. 
The server responds with its confirmation in the 'ServerFinished' message,
authenticating the handshake transcript using MAC key fks.
In the same flight, the server sends application data encrypted under keys derived from SATS. 
Once the client receives and verifies ServerFinished, the server is explicitly authenticated.
*/


//*== NSSK == *//
/*
Here, Alice A initiates the communication to Bob B.
S is a server trusted by both parties. In the communication:
1. A and B are identities of Alice and Bob repectively.
2. Kas is a symmetric key known only to  A and S
3. Kbs is a symmetric key known only to  B and S
4. Na and Nb are nonces generated by A and B repectively.
5. Kab is a symmetric, generated key, which will be the session key of the 
session between A and B.
6. The encryption and decryption in this protocol is performed by senc/sdec. 

The protocol can be specified as follows:
1. Alice sends a message including his and Bob's identites and a fresh nonce Na 
to the server, telling the server she wants to communicates wit Bob.
2. The server generates Kab and sends back to Alice a copy encrypted under 
Kbs for Alice to forward to Bob and also a copy for Alice. 
Since Alice may be requesting keys for several different people,
the nonce assures Alice that the message is fresh and that 
the server is replying to that particular message and the inclusion of Bob's name
tells Alice who she is to share this key with. 

3. Alice forwards the message to Bob who can decrypt it 
with the key he shares with the server Kbs, thus authenticating the data.
4. Bob sends Alice a nonce Nb encrypted under Kab to show that he has the key.
5. Alice performs a simple operation 'dec' on the nonce, re-encrypts it 
and sends it back verifying that she is still alive and that she holds the key.
*/


/*=== Prompt 1 ===*/
/*=== promop with well-formed lambda expressions ===*/
You are a Lambda Calculus Expression expert in cryptographic protocol field. Now you need to parse texts into lamba calculus. There are some Lambda Calculus Expression template you may use: 
1. Send(A:agent, B:agent, m:msg): Agent A sends message m to agent B. The Send function is limited to 3 arguments.
2. Recv(B:agent, A:agent, n:msg): Agent B receives message n from agent A.
3. Gen(A:agent, n:nonce): Agent A generates a fresh nonce n.
4. Knows(A:agent, n1:nonce, n2:nonce, ...): Agent A initially knows items n1, n2, etc., which are infrastructure components like keys.
5. Op(A:agent, func(msg)): Agent A performs operations like aenc/adec/concat on messages to produce a new message m. \
The func in Op must match the corresponding predicate described in natural language. \
Note: Expressions listed above cannot serve as arguments to Op; for example, Op(R, Gen/Send/, ...) is prohibited.

For each Send, there should be a corresponding Recv.
A message should be binded to a variable before sending it.

our task is to complete each expression by directly filling in the placeholders denoted by /* >>The lambda calculus << */. \
Do not include any explanations, comments, or additional text outside of the required expressions. 
Here are a list of ASSITANT MESSAGE and USER MESSAGE:

USER
Alice and Bob shares a symetric key Kab initially.
/* >>The lambda calculus << */

ASSITANT
/* 
Knows(role(Alice), Kab)
Knows(role(Bob), Kab)
*/

USER
Bob generates a fresh nonce m and computes H as the hash of m \
with its identity. Then Bob sends it to Alice.
/* >>The lambda calculus << */


ASSITANT
/* 
Gen(Bob, m)
Op(Bob, assign(H, hash(concat(m, idB))))
Op(Bob, assign(cypher, senc(H, Kab)))
Send(Bob, Alice, cypher)
Recv(Alice, Bob, cypher)
*/

USER
Alice starts the protocol by sending her identity A together with a freshly generated random number Na. \
This message is encrypted using an asymmetric encryption algorithm with B's public key (denoted pub(B)).
/* >>The lambda calculus << */

ASSITANT
/* 
Gen(Alice, Na)
Op(Alice, assign(message1, aenc(concat(idA, Na), pkB)))
Send(Alice, Bob, message1)
*/

USER
We suppose that only agent Bob (whose identity is B) knows the secret key corresponding to pub(B). \
Next Bob receives the message {A, Na}pub(B) sent by Alice. 
/* >>The lambda calculus << */

ASSITANT
/* 
Knows(role(Bob), pkA, pkB)
Recv(Bob, Alice, message1)
Op(Bob, adec(message1, skB))
*/

USER
Using his private key, Bob decrypts the message. He sends the received nonce Na together with a freshly generated nonce Nb \
encrypted with A's public key (pub(A)) to Alice. Finally Alice receives the message {Na, Nb}pub(A).
/* >>The lambda calculus << */

ASSITANT
/* 
Op(Bob, adec(message1, skB))
Gen(Bob, Nb)
Op(Alice, assign(message2, aenc(concat(idA, Na), pkB)))
Send(Bob, Alice, message2)
Recv(Alice, Bob, message2)
*/

USER
Then She sends the nonce Nb to Bob encrypted with Bob's public key.
/* >>The lambda calculus << */

ASSITANT
/* 
Op(Alice, assign(cypher2, aenc(Nb, pkB)))
Send(Alice, Bob, cypher2)
Recv(Bob, Alice, cypher2)
*/

*/