running_example = """\
A client C generates a fresh symmetric key k, encrypts it with the \
public key pkS of a server S, and sends it to S. The server confirms \
the key's receipt by sending the hash of the key back to the client.
"""

exercise = """\
Alex computes a nonce and sends it to Blake. (A -> B: ANonce)
When Blake receives Alex's nonce, Blake computes their own nonce and sends it to Alex. (B -> A: BNonce)
When Alex receives Blake's nonce, Alex does two things: Alex installs a session key SK, which is derived 
from ANonce and BNonce by applying a key derivation function (i.e., SK = kdf(ANonce, BNonce)).
Once the session key is installed, Alex sends a message with the string "ACK"  to Blake (A -> B: "ACK") 
and switches to a 'DONE' state to indicate that the protocol has been executed successfully on Alex's side.
When Blake receives the "ACK" message, Blake also computes the session key SK = kdf(ANonce, BNonce), \
installs it and switches to a 'DONE' state.    
"""

nssk = """\
Here, Alice A initiates the communication to Bob B. 
S is a server trusted by both parties. In the communication:
1. A and B are identities of Alice and Bob repectively.
2. Kas is a symmetric key known only to  A and S
3. Kbs is a symmetric key known only to  B and S
4. Na and Nb are nonces generated by A and B repectively.
5. Kab is a symmetric, generated key, which will be the session key of the 
session between A and B.

Both A, B and S knows the identities of A and B.

The protocol can be specified as follows:
1. Alice sends a message <A, B, Na> (where A, B indicates the identities and Na a fresh nonce) \
and a fresh nonce Na to the server, telling the server she wants to \
communicates wit Bob.

2. The server generates Kab and sends back to Alice a copy encrypted under \
Kbs for Alice to forward to Bob and also a copy for Alice. \
Since Alice may be requesting keys for several different people, \
the nonce assures Alice that the message is fresh and that \
the server is replying to that particular message and the inclusion of Bob's name \
tells Alice who she is to share this key with ( S -> A: {Na, Kab, B, {Kab, A}Kbs}Kas ).

3. Alice forwards the message senc(<Kab, A>, Kbs) to Bob who can decrypt it \
with the key he shares with the server Kbs, thus authenticating the data. 

4. Bob sends Alice a nonce Nb encrypted under Kab to show that he has the key.

5. Alice performs a simple operation 'dec' on the nonce (dec(Nb)), re-encrypts it \
and sends it back verifying that she is still alive and that she holds the key.
"""

Otway_Rees = """\
In the following description, `A`, `B` are the identities of principal A, B repectively.
`kas`, `kab` are shared symmetric keys between A and S, between A  and B respectively.
A knows the key `Kas`, `A` and `B` initially,
B knows symmetric key `Kbs`, `A`, `B` and S knows both `Kas` and `Kbs` and identits `A` and `B` initially.

1. A sends B the protocol session number I (a fresh nonce), his identity, the identity of the principal
with whom he wishes to communicate, and a message encrypted with the key `kas`, i.e.,
the message1 is `<I,A,B,{Na,I,A,B}kas>`.

2. B receives A's message and concats it with his own message encrypted with the key kbs (`{Nb,I,A,B}kbs`) before  
sending it to the trusted server S. 

3. S receives the message and is able to retrieve the session number, the random number 
from A: `Na`, using his shared key kas, the random number from B: `Nb` with the other shared 
key `kbs`, and generates the session key `kab`. With this information, he is able to generate
message 3 and sends it to B. message3=`I,{Na,kab}kas,{Nb, kab}kbs`

4. The principal B receives message 3, removes the last encrypted part with his 
shared key, decrypts this sub-message with his key `kbs`, retrieves the session key `kab`, 
and sends the remaining part of the message to A. In this way, A is also able to 
retrieve the session key kab, based on the last part of message 4 (`I,{Na,kab}kas`),
by using his shared key kas, and the two principals are able to start communicating. 
"""

# Denning_Sacco = """\
# The Denning-Sacco protocol facilitates secure communication by allowing two parties (Alice and Bob) \
# to establish a shared session key via a trusted Key Distribution Center (KDC). \
# Alice initiates the communication by sending a message to the KDC (S), \
# requesting a session key to communicate with Bob (B). The message includes the identities of Alice (A) and Bob (B). \
# The KDC responds to Alice with an encrypted message using Kas. The message includes: \
# (1) The identity of Bob (B), indicating the session key is for communication with Bob. \
# (2) The session key (Kab) for Alice and Bob to use. \
# (3) A timestamp (T) to ensure the message's freshness which is a fresh nonce. \
# An encrypted part for Bob {Kab, A, T}Kbs, which includes the session key (Kab), the identity of Alice (A),\
# and the timestamp (T), all encrypted with Bob's key (Kbs). This ensures that only Bob can decrypt and use this information.\
# Alice forwards the encrypted part {Kab, A, T}Kbs to Bob. \
# This message allows Bob to decrypt it using his key (Kbs) to retrieve the session key (Kab) \
# and verify Alice's identity and the message's freshness with the timestamp.
# """ 

Denning_Sacco = """\
The Denning-Sacco protocol facilitates secure communication by allowing two parties (Alice and Bob) \
to establish a shared session key via a trusted Key Distribution Center (KDC). \
    
Alice initiates the communication by sending a message to the KDC (S), \
requesting a session key to communicate with Bob (B). The message includes the identities of Alice (A) and Bob (B). 
    
The KDC responds to Alice with an encrypted message using Kas. The message includes: \
(1) The identity of Bob (B), indicating the session key is for communication with Bob. \
(2) The session key (Kab) for Alice and Bob to use. \
(3) A timestamp (T) to ensure the message's freshness which is a fresh nonce.
(4) An encrypted part for Bob {Kab, A, T}Kbs, which includes the session key (Kab), the identity of Alice (A),\
and the timestamp (T), all encrypted with Bob's key (Kbs). This ensures that only Bob can decrypt and use this information.

Alice forwards the encrypted part {Kab, A, T}Kbs to Bob. \
This message allows Bob to decrypt it using his key (Kbs) to retrieve the session key (Kab) \
and verify Alice's identity and the message's freshness with the timestamp.
""" 

Kao_Chow_Authentication_V1 = """\
1. Initiation by A: The process begins with Principal A (the initiator) sending a message \
to the Server (S). This message includes A's identity, B's identity (the intended \
communication partner), and a nonce (Na) generated by A. The nonce is a random number \
used to ensure freshness and prevent replay attacks.

2. Server's Response to B: Upon receiving the message from A, the Server constructs two encrypted packages:
(package 1) The first package contains A's identity, B's identity, the nonce Na, and \
the session key (Kab) intended for use between A and B. This package is encrypted with \
the server's key shared with A (Kas), ensuring that only A can decrypt it.
(package 2) The second package is similar but is encrypted with the server's key shared with B (Kbs), \
ensuring that only B can decrypt it. The Server sends this compound message to B, \
facilitating the secure distribution of the session key (Kab).

3. B's Response to A: B decrypts the received package using Kbs, extracts the session \
key (Kab), and sends a message to A. This message (<package1, package2, Nb>) includes:
(package 1) The encrypted package intended for A (using Kas), which A can decrypt \
using her shared key with the server to verify the session key.
(package 2) An encrypted version of the nonce Na using the session key (Kab), \
allowing A to verify that B has correctly received and decrypted the session key.
(package 3) B's nonce (Nb), introducing a challenge for A to ensure B's message's authenticity and freshness.
B -> A: <package1, package2, Nb>

4. Final Acknowledgment by A: A decrypts B's message, verifies the nonce Na, \
and responds to B's challenge by encrypting B's nonce (Nb) with the session key (Kab) \
and sending it back to B. This step completes the mutual authentication process, \
confirming to B that A has successfully received and acknowledged the session key (Kab).\
"""


# Kao_Chow_Authentication_V1 = """\
# A, B, S :  	principal
# Kab, Kbs, Kas : shared key

# A generates a fresh nonce Na, then send message to S:
# 1.  	A	->	S	:  	<A, B, Na>

# 2.  	S	->	B	:  	<{A, B, Na, Kab}Kas, {A, B, Na, Kab}Kbs>

# B generates a fresh nonce Nb, then send message to A:
# 3.  	B	->	A	:  	<{A, B, Na, Kab}Kas, {Na}Kab, Nb>

# 4.  	A	->	B	:  	<{Nb}Kab>
# """

# Yahalom = """\
# Protocol Steps:
# A -> B: Alice starts the protocol by sending her identity (A) and a freshly generated \
# nonce (Na) to Bob. This message indicates Alice's intention to communicate securely and \
# serves as a challenge to prove Bob's identity in later steps.

# B -> S: Bob responds to Alice's request by sending a message to the Server (S). \
# This message includes Bob's identity (B), and an encrypted package {A, Na, Nb}Kbs \
# containing Alice's identity, Alice's nonce (Na), and Bob's freshly generated nonce (Nb), \
# all encrypted with Bob's key (Kbs). This ensures that only the Server can decrypt and \
# process the message, proving Bob's identity to the Server.

# S -> A: The Server processes Bob's request and sends two encrypted messages: \
# The first message {B, Kab, Na, Nb}Kas is encrypted with Alice's key (Kas) and includes \
# Bob's identity (B), the session key (Kab), and both nonces (Na, Nb). This message assures \
# Alice of Bob's participation and provides the session key.The second message {A, Kab}Kbs \
# is encrypted with Bob's key (Kbs) and includes Alice's identity (A) and the session key (Kab), \
# intended for Bob.

# A -> B: Alice forwards the second message {A, Kab}Kbs to Bob, proving her ability to \
# communicate with the Server and her possession of the session key. She also sends an \
# encrypted message {Nb}Kab, which contains Bob's nonce encrypted with the session key (Kab). \
# This step confirms to Bob that Alice has received and accepted the session key, \
# and it validates Alice's identity to Bob.
# """

Yahalom = """\
Alice and Server shares a key Kas, Bob shares a Kbs with Server initially.
All the identitis  can be known publickly.

A -> B: Alice starts the protocol by sending her identity (A) and a freshly generated \
nonce (Na) to Bob. This message indicates Alice's intention to communicate securely and \
serves as a challenge to prove Bob's identity in later steps.

B -> S: Bob responds to Alice's request by sending a message to the Server (S). \
This message includes Bob's identity (B), and an encrypted package {A, Na, Nb}Kbs \
containing Alice's identity, Alice's nonce (Na), and Bob's freshly generated nonce (Nb), \
all encrypted with Bob's key (Kbs). This ensures that only the Server can decrypt and \
process the message, proving Bob's identity to the Server.

S -> A: The Server processes Bob's request and sends a message including two packages: \
The first package {B, Kab, Na, Nb}Kas is encrypted with Alice's key (Kas) and includes \
Bob's identity (B), the session key (Kab), and both nonces (Na, Nb). This message assures \
Alice of Bob's participation and provides the session key.The second package {A, Kab}Kbs \
is encrypted with Bob's key (Kbs) and includes Alice's identity (A) and the session key (Kab), \
intended for Bob.

A -> B: Alice forwards the second package {A, Kab}Kbs to Bob, proving her ability to \
communicate with the Server and her possession of the session key. She also sends an \
encrypted message {Nb}Kab, which contains Bob's nonce encrypted with the session key (Kab). \
This step confirms to Bob that Alice has received and accepted the session key, \
and it validates Alice's identity to Bob.
"""


X509_1 = """\
The CCITT X.509 version 1 protocol is a security mechanism designed to ensure secure \
communication between two principals, often referred to as Alice (A) and Bob (B), within a network. 
Both Ta, Na, Xa and Ya are fresh nonce. Tha public key of both roles are known publicly.

Alice initiates communication by sending a message to Bob that includes her identity (A), \
a timestamp (Ta) to mark the message's time, a nonce (Na) for ensuring the message's freshness, \
Bob's identity (B), some data (Xa), and user-specific data (Ya) encrypted with Bob's public key (PK(B)) for confidentiality. \

This entire package, except the encrypted part {Ya}PK(B), is then signed with Alice's private key (SK(A)) to ensure authenticity. \
The signed part includes a hash of the entire message (including {Ya}PK(B)) to verify the integrity and origin of the message. \
For simplification, the message which is sent from A to B is  `<A, Ta, Na, B, Xa, {Ya}PK(B), hash_part, {hash_part}SK(A)>` \
where `<...>` operator denotes concatation of string, {}PK denotes asymmetric.
"""
temp = """<A, Ta, Na, B, Xa, {Ya}PK(B), {h(Ta, Na, B, Xa, {Ya}PK(B))}SK(A)>"""



Woo_Lam_Pi_f = """\
The Woo and Lam Pi f protocol is a variant of the original Woo and Lam Pi protocol, \
designed for secure authentication between two principals with the assistance of a trusted third party. \
This version specifically emphasizes the use of shared keys for encryption and authentication. \
Here's a concise description:
1. Alice starts the authentication process by sending her identity (A) to Bob, \
signaling her intention to establish a secure communication.

2. Bob generates a nonce (Nb) and sends it to Alice. \
This nonce acts as a challenge to prove Alice's identity in a secure manner.

3. Alice constructs a message containing her identity (A), Bob's identity (B), \
and the nonce (Nb). She then encrypts this message with the shared key between her and the Server (S), \
Kas, and sends this encrypted message to Bob. This step aims to prove Alice's \
identity to Bob by utilizing the shared secret with the Server.

4. Bob forwards the message received from Alice to the Server for verification. \
He includes the original message from Alice and adds Alice's identity (A), his own identity (B) and the \
nonce (Nb) for context. This entire package is encrypted with the shared key between \
Bob and the Server, Kbs, ensuring that only the Server can decrypt and verify the contents.

5. The Server decrypts Bob's message using Kbs, verifies the authenticity and integrity \
of Alice's message, and then constructs a new message containing Alice's and Bob's \
identities along with the nonce (Nb). This message is encrypted with the shared key \
between Bob and the Server, Kbs, and sent back to Bob. 
This confirms to Bob that Alice's identity has been successfully authenticated.
"""
splice = """\
The SPLICE/AS protocol is designed to facilitate secure communication between \
a client (C) and a server (S) with the assistance of an authentication server (AS). \
This protocol establishes trust and secure communication channels by using public \
and private keys, nonces, and timestamps. Here's a concise explanation:
1. Client to Authentication Server: `<C, S, N1>`
The client (C) initiates the protocol by sending a message to the authentication \
server (AS) containing its own identity, the server's identity (S), and a nonce (N1). \
This step is aimed at requesting a certificate for the server's public key.
2. Authentication Server to Client: `<AS, {AS, C, N1, pk(S)}sk(AS)>`
The authentication server responds by sending a certificate back to the client, \
which includes the identities of both the AS and the client, the nonce N1, \
and the server's public key, all signed with the authentication server's private key. \
This certificate ensures the client that the server's public key is legitimate.
3. Client to Server: `<C, S, {C, T, L, {N2}pk(S)}sk(C)>`
The client then sends a message to the server containing both identities (C and S), \
a timestamp (T), a lifetime (L) for the message, and an encrypted nonce (N2) using \
the server's public key, all signed with the client's private key. \
This encrypted nonce can be used as a symmetric key for secure communication.
4. Server to Authentication Server: `<S, C, N3>`\
The server, needing to authenticate the client, sends a message to the authentication \
server containing its own identity, the client's identity, and a nonce (N3). This step \
requests a certificate for the client's public key.
5. Authentication Server to Server: `<AS, {AS, S, N3, pk(C)}sk(AS>`
The authentication server responds with a certificate for the client's public key, \
including the identities of both the AS and the server, the nonce N3, and the client's public key, \
all signed with the AS's private key. This certificate authenticates the client's public key to the server.
6. Server to Client: `<S, C, {S, inc(N2)}pk(C)>`
Finally, the server sends a message to the client, \
including both identities and an incremented nonce (N2), encrypted with the client's public key. \
This confirms the secure channel's establishment and the nonce's acceptance for future symmetric encryption.
"""

sigfox = """\
SigFox essentially uses TLS 1.2 PKC (public key cryptography) and shares its security goals. 
The server pushes an asymmetric-encrypted notification (na) with its signature to devices.
The server uses the public key of the device (pkB) and generates a fresh data item na. It then encrypts the data and the server's public key \
(pkA) using the the public key of client pkB, to generate the message aenc(<pkA, na>, pkB). \
Then the server signs the message using its own private key skA and sends the message along with its signature (<mess, sig>) to the device. \
Once the device receives the asymmetrically encrypted message with a signature, then perform signature verification on received message.
"""

tmp = """
Both the public keys of client and Server can be known by each. The secrect key is private, only known by himself.
The SigFox server pushes an asymmetric-encrypted notification (na) with its signature to devices.
The server uses the public key of device (pkB) and generates a fresh data item na. It then encrypts the data and the server's public key \
(pkA) using the the public key of client, pkB to generate the message aenc(<pkA, na>, pkB). \
Then the server signs the message using its own private key ltkA. The server sends the message along with its signature (<mess, sig>) to the device. \
Device receives the asymmetrically encrypted message with a signature, then perform signature \
verification on received message."""

Neu_Stu = """\
1. Initial Request by A:
Principal A initiates the protocol by sending its identity along with a nonce (Na) to Principal B. \
The nonce serves as a challenge to ensure the freshness of the session and protect against replay attacks.

2. Request Forwarding by B (B	->	S	:  	B, {A, Na, Tb}Kbs, Nb):
Upon receiving A's request, B forwards this request to the Server (S). B includes its own identity, \
a package encrypted with B's server-shared key (Kbs) containing A's identity, the nonce Na, and a \
timestamp (Tb) to ensure timeliness. B also generates and sends its own nonce (Nb) to the server, \
aiming for mutual authentication.

3. Server's Response to A (S -> A: <package1, package2>):
The Server responds with two encrypted packages:
(package 1) The first package is encrypted with A's server-shared key (Kas) and contains B's identity, \
A's nonce (Na), a session key (Kab) for A and B to use, and the timestamp (Tb).
(package 2) The second package, intended for B, is encrypted with B's server-shared key (Kbs) and \
includes A's identity, the session key (Kab), and the timestamp (Tb). The server also sends back \
B's nonce (Nb) to confirm its receipt.

4. Transmission to B (A -> B: 	{A, Kab, Tb}Kbs, {Nb}Kab ):
A sends to B the second package it received from the server, proving it has successfully decrypted \
the server's message and obtained the session key (Kab). A also sends Nb encrypted with Kab, \
ensuring that only B can decrypt it, which proves to B that A possesses the correct session key.

5. First Message Exchange (A	->	B	:  	Ma, {A, Kab, Tb}Kbs):
A sends a message (Ma) directly to B, along with the repeated transmission of the second package \
({A, Kab, Tb}Kbs). This serves as an additional authentication step and ensures that \
both parties acknowledge the established session key.

6. Response by B (B	->	A	:  	Mb, {Ma}Kab):
B responds with its own message (Mb) and the encryption of A's message (Ma) using the session key (Kab), \
further confirming the successful establishment of the secure session and mutual authentication.

7. Final Acknowledgment by A (A	->	B	:  	{Mb}Kab):
A completes the protocol by sending the encryption of B's message (Mb) using the session key (Kab), \
finalizing the mutual authentication process.
"""


nsl = """\
Alice knows his sercet key skA, public key pkA and the public of bob pkB.
Alice starts the protocol by sending her identity A together with a freshly generated random number Na. \
This message is encrypted using an asymmetric encryption algorithm with B's public key (denoted pub(B)). \
We suppose that only agent Bob (whose identity is B) knows the secret key corresponding to pub(B). \
Next Bob receives the message {A, Na}pub(B) sent by Alice. \
Using his private key, Bob decrypts the message. He sends the received nonce Na together with a freshly generated nonce Nb \
encrypted with A's public key (pub(A)) to Alice. Finally Alice receives the message {Na, Nb}pub(A).\
She decrypts the message and checks that the nonce NA corresponds to the nonce previously generated and sent to Bob. \
She sends the nonce Nb to Bob encrypted with Bob's public key. Upon reception of this message Bob \
decrypts it and checks that the nonce corresponds to the one previously generated.\
"""

ssh = """\
SSH protocol: 
The following steps are used to exchange a key. Here C is the client; S is the server; p is a large safe \
prime; g is a generator for a subgroup of GF(p); V_S is S's identification string; \
V_C is C's identification string; K_S is S's public host key; I_C is C's SSH_MSG_KEXINIT message and \
I_S is S's SSH_MSG_KEXINIT message that have been exchanged before this part begins.

C generates a random number x and computese = g^x. C sends e to S.

S generates a random number y and computes f = g^y. S receives e. It computes K = e^y, \
H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K) (these elements are encoded according to their types; \
see below), and signature s on H with its private host key. S sends (K_S || f || s) to C. The signing operation \
may involve a second hashing operation.

C verifies that K_S really is the host key for S (e.g., using certificates or a local database). C is also allowed \
to accept the key without verification; however, doing so will render the protocol insecure against active attacks \
(but may be desirable for practical reasons in the short term in many environments). C then computes K = f^x,\
H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K), and verifies the signature s on H.
"""


ssh = """\
The Diffie-Hellman (DH) key exchange provides a shared secret that
cannot be determined by either party alone.  The key exchange is
combined with a signature with the host key to provide host
authentication.  This key exchange method provides explicit server
authentication as defined in Section 7.
The following steps are used to exchange a key.  In this, C is the
client; S is the server; p is a large safe prime; g is a generator
for a subgroup of GF(p); q is the order of the subgroup; V_S is S's
identification string; V_C is C's identification string; K_S is S's
public host key; I_C is C's SSH_MSG_KEXINIT message and I_S is S's
SSH_MSG_KEXINIT message that have been exchanged before this part
begins.

1. C generates a random number x (1 < x < q) and computes
    e = g^x mod p.  C sends e to S.

2. S generates a random number y (0 < y < q) and computes
    f = g^y mod p.  S receives e.  It computes K = e^y mod p,
    H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K)
    (these elements are encoded according to their types; see below),
    and signature s on H with its private host key.  S sends
    (K_S || f || s) to C.  The signing operation may involve a
    second hashing operation.

3. C verifies that K_S really is the host key for S (e.g., using
    certificates or a local database).  C is also allowed to accept
    the key without verification; however, doing so will render the
    protocol insecure against active attacks (but may be desirable for
    practical reasons in the short term in many environments).  C then
    computes K = f^x mod p, H = hash(V_C || V_S || I_C || I_S || K_S
    || e || f || K), and verifies the signature s on H.


This is implemented with the following messages.  The hash algorithm
for computing the exchange hash is defined by the method name, and is
called HASH.  The public key algorithm for signing is negotiated with
the SSH_MSG_KEXINIT messages.


The key exchange produces two values: a shared secret K, and an
exchange hash H.  Encryption and authentication keys are derived from
these.  The exchange hash H from the first key exchange is
additionally used as the session identifier, which is a unique
identifier for this connection.  It is used by authentication methods
as a part of the data that is signed as a proof of possession of a
private key.  Once computed, the session identifier is not changed,
even if keys are later re-exchanged.

Each key exchange method specifies a hash function that is used in
the key exchange.  The same hash algorithm MUST be used in key
derivation.  Here, we'll call it HASH.

Encryption keys MUST be computed as HASH, of a known value and K, as
follows:

o  Initial IV client to server: HASH(K || H || "A" || session_id)
    (Here K is encoded as mpint and "A" as byte and session_id as raw
    data.  "A" means the single character A, ASCII 65).
o  Initial IV server to client: HASH(K || H || "B" || session_id)
o  Encryption key client to server: HASH(K || H || "C" || session_id)
o  Encryption key server to client: HASH(K || H || "D" || session_id)
o  Integrity key client to server: HASH(K || H || "E" || session_id)
o  Integrity key server to client: HASH(K || H || "F" || session_id)

Key data MUST be taken from the beginning of the hash output.  As
many bytes as needed are taken from the beginning of the hash value.
If the key length needed is longer than the output of the HASH, the
key is extended by computing HASH of the concatenation of K and H and
the entire key so far, and appending the resulting bytes (as many as
HASH generates) to the key.  This process is repeated until enough
key material is available; the key is taken from the beginning of
this value. 
"""

edhoc = """\
edhoc:"""

kemtls = """
There are conceptually three phases to KEMTLS, each of which
establishes one or more “stage” keys.
Phase 1: Ephemeral key exchange using KEMs. 
After establishing the TCP connection, 
the KEMTLS handshake begins with the client sending one or more ephemeral KEM public keys pke
in its 'ClientHello' message, as well as the list of public key authentication, key exchange, 
and authenticated encryption methods it supports. 

The server responds in the 'ServerHello' message
with an encapsulation cte against pke and the algorithms it selected from the client's proposal; 
note that if (none of) the pke the client sent was for the key-exchange method the server selected,
a special HelloRetryRequest message is sent, prompting a new 'ClientHello' message.
Nonces rc and rs are also transmitted for freshness.

At this point, the client and server have an unauthenticated shared secret sse.
KEMTLS follows the TLS 1.3 key schedule, which applies a sequence of HKDF operations to the shared secret sse 
and the transcript to derive (a) the client and server handshake traffic secrets CHTS and SHTS 
which are used to encrypt subsequent flows in the handshake, and (b) a "derived handshake secret" dHS
which is kept as the current secret state of the key schedule.

Phase 2: Implicitly authenticated key exchange using KEMs.
In the same server-to-client flight as 'ServerHello', 
the server also sends a certificate containing its long-term KEM public key pks.
The client encapsulates against pks and sends the resulting ciphertext in its 'ClientKemCiphertext' message. 
This yields an implicitly authenticated shared secret ssS.
The key schedule's secret state dHS from phase 1 is combined with ssS using HKDF 
to give an "authenticated handshake secret" AHS from which are derived 
(c) the client and server authenticated handshake traffic secrets CAHTS and SAHTS 
which are used to encrypt subsequent flows in the handshake, 
and (d) an updated secret state dAHS of the key schedule. 
A master secret MS can now be derived from the key schedule's secret state dAHS. 
From the master secret, several more keys are derived: 
(e) "finished keys" fkc and fks which will be used to authenticate the handshake 
and (f) client and server application transport secrets CATS and SATS 
from which are derived application encryption keys. 
The client now sends a confirmation message 'ClientFinished' to the server 
which uses a message authentication code with key fkc to authenticate the handshake transcript. 
In the same flight of messages, 
the client is also able to start sending application data encrypted under keys derived from CATS; 
this is implicitly authenticated.

Phase 3: Confirmation / explicit authentication. \
The server responds with its confirmation in the 'ServerFinished' message,
authenticating the handshake transcript using MAC key fks.
In the same flight, the server sends application data encrypted under keys derived from SATS. 
Once the client receives and verifies ServerFinished, the server is explicitly authenticated."""

naxos = """\
In this protocol, each party x has a long-term private key lkx and a corresponding public key pkx = 'g'^lkx, \
where 'g' is a generator of the Diffie-Hellman group. Because 'g' can be public, we model it as a public \
constant. Two different hash functions h1 and h2 are used.
To start a session, the initiator I first creates a fresh nonce eskI, also known as I's ephemeral (private) key. \
He then concatenates eskI with I's long-term private key lkI, hashes the result using the hash function h1, and \
sends 'g'^h1(eskI ,lkI) to the responder. The responder R stores the received value in a variable X, computes a \
similar value based on his own nonce eskR and long-term private key lkR, and sends the result to the initiator, \
who stores the received value in the variable Y. Finally, both parties compute a session key (kI and kR, respec-\
tively) whose computation includes their own long-term private keys, such that only the intended partner can \
compute the same key.
"""
lake = """\

"""
DB = {
    "running_ex" : running_example,
    "nsl": nsl,
    "exercise" : exercise,
    "Denning_Sacco": Denning_Sacco,
    "nssk": nssk,
    "or" : Otway_Rees,
    "Yahalom" : Yahalom,
    "kca" : Kao_Chow_Authentication_V1,
    "X509_1" : X509_1,
    "Woo_Lam_Pi_f": Woo_Lam_Pi_f,
    "splice": splice,
    "sigfox": sigfox,
    "Neu_Stu": Neu_Stu,
    "ssh": ssh,
    # "edhoc": edhoc,
    "kemtls": kemtls,
    "naxos": naxos,
    # "lake": lake,
}

if __name__ == "__main__":
    print(Denning_Sacco)